
import re
import json

def generate_draft_category_from_prompt(prompt: str) -> dict:
    """
    (Simulated AI) Parses a natural language prompt to generate a draft playbook category.
    Translates phrases like "run X and Y in parallel, then Z" into execution groups.
    """

    # 1. Extract the category name (e.g., "create a category named 'Shipping'")
    category_name_match = re.search(r"(?:category|named|name|for) '([\w\s]+)'", prompt, re.IGNORECASE)
    if category_name_match:
        category_name = category_name_match.group(1).strip().lower().replace(" ", "_")
    else:
        category_name = "new_draft_category"

    # 2. Identify playbook tasks and their execution order
    playbooks = []
    execution_order = 1

    # Split the prompt into clauses based on sequencing words ("then", "after")
    clauses = re.split(r'\b(then|after that|after)\b', prompt, flags=re.IGNORECASE)

    for clause in clauses:
        # Check for parallel execution keywords
        is_parallel = re.search(r'\b(in parallel|at the same time)\b', clause, flags=re.IGNORECASE)
        
        tasks_in_clause = re.findall(r'\b(sms|mail|email|api|call)\b', clause, flags=re.IGNORECASE)

        if not tasks_in_clause: continue

        for i, task_type in enumerate(tasks_in_clause):
            task_type = task_type.lower()
            playbook = _create_draft_playbook_for_task(task_type, execution_order)
            playbooks.append(playbook)
            
            # If tasks are NOT in parallel, increment the order for each one in the clause
            if not is_parallel:
                execution_order += 1
        
        # If tasks in the clause ARE parallel, they share the same order.
        # We only increment the main order *after* the parallel group is processed.
        if is_parallel:
            execution_order += 1

    return {
        "id": category_name,
        "playbooks": playbooks
    }

def _create_draft_playbook_for_task(task_type: str, order: int) -> dict:
    """Helper function to generate a default playbook for a given task type."""
    playbook_id = f"{task_type}_playbook_{order}"
    playbook_name = f"Run {task_type.capitalize()} Task"

    if task_type in ["mail", "email"]:
        task = {
            "task_type": "send_message",
            "service_config": {
                "provider": "email",
                "message_details": {
                    "to": "{customer.email}", "subject": "Update", "body_html": "<p>Hello!</p>"
                }
            }
        }
    elif task_type == "sms":
        task = {
            "task_type": "send_message",
            "service_config": {
                "provider": "twilio_sms",
                "message_details": {"to": "{customer.phone}", "body": "Update!"}
            }
        }
    elif task_type in ["api", "call"]:
        task = {
            "task_type": "api_push",
            "api_config": {
                "method": "POST",
                "url_template": "https://api.example.com/v1/update",
                "payload_template": {"doc_id": "{document_id}"}
            }
        }
    else:
        return None # Should not happen based on regex

    return {
        "id": playbook_id,
        "name": playbook_name,
        "status": "draft",
        "execution_order": order,
        "steps": [{
            "step": 1,
            "name": f"Autogenerated {task_type} step",
            **task
        }]
    }

def blind_extract_key_values(document_text: str) -> dict:
    """
    (Simulated AI) Performs a general, "blind" extraction of key-value pairs from document text.
    In a real implementation, this would use a powerful LLM with a generic prompt.
    """
    # This is a simplified simulation. A real implementation would use a much more robust regex
    # or a proper NLP model.
    extracted_data = {}
    # Example: Find things that look like "Key: Value"
    for match in re.finditer(r"([\w\s]+):\s*([\w\s\d-]+)", document_text):
        key = match.group(1).strip().lower().replace(" ", "_")
        value = match.group(2).strip()
        extracted_data[key] = value
        
    # Simulate finding some other common fields
    if "invoice" in document_text.lower():
        inv_match = re.search(r"invoice no[.:]?\s*(\d+)", document_text, re.IGNORECASE)
        if inv_match: extracted_data["invoice_number"] = inv_match.group(1)

    if not extracted_data:
        return {"status": "warning", "message": "Could not automatically extract any key-value pairs."}

    return {"status": "success", "extracted_data": extracted_data}

def answer_document_question(prompt: str, document_record: dict) -> dict:
    """
    (Simulated AI) Answers questions about a document or suggests modifications.
    """
    prompt = prompt.lower()
    
    # Intent: Ask for a value
    if prompt.startswith("what is the") or prompt.startswith("get the"):
        key_match = re.search(r"what is the '([\w_]+)'", prompt) or re.search(r"get the '([\w_]+)'", prompt)
        if key_match:
            key = key_match.group(1)
            value = document_record.get("global_key_values", {}).get(key)
            if value:
                return {"answer": f"The value for '{key}' is '{value}'."}
            else:
                return {"answer": f"I could not find a value for '{key}' in this document."}

    # Intent: Modify a value
    elif prompt.startswith("change the") or prompt.startswith("update the"):
        update_match = re.search(r"(?:change|update) the '([\w_]+)' to '([\w\s\d-]+)'", prompt)
        if update_match:
            key, new_value = update_match.groups()
            
            # Prepare a proposed change for user confirmation
            return {
                "action": "propose_update",
                "update_details": {
                    "scope": "global_key_values",
                    "key": key,
                    "new_value": new_value
                },
                "confirmation_prompt": f"Are you sure you want to update the global value '{key}' to '{new_value}'?"
            }

    # Intent: Add a new ad-hoc key-value
    elif prompt.startswith("add a new field") or prompt.startswith("add a key"):
        add_match = re.search(r"add a new field '([\w_]+)' with value '([\w\s\d-]+)'", prompt)
        if add_match:
            key, value = add_match.groups()
            return {
                "action": "propose_update",
                "update_details": {
                    "scope": "global_key_values",
                    "key": key,
                    "new_value": value
                },
                "confirmation_prompt": f"Are you sure you want to add the new field '{key}' with value '{value}'?"
            }
            
    return {"answer": "I'm sorry, I can only get, update, or add key-values for this document right now."}
